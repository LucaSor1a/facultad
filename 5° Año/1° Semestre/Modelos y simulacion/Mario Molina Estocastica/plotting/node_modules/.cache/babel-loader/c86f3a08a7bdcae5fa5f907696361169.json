{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.interval = exports.builtIn = void 0;\n\nvar built_in_math_eval_1 = __importDefault(require(\"built-in-math-eval\"));\n\nvar interval_arithmetic_eval_1 = __importDefault(require(\"interval-arithmetic-eval\"));\n\nvar samplers = {\n  interval: interval_arithmetic_eval_1.default,\n  builtIn: built_in_math_eval_1.default\n};\n\nif (global.math) {\n  samplers.builtIn = global.math.compile;\n}\n\nfunction generateEvaluator(samplerName) {\n  function doCompile(expression) {\n    // compiles does the following\n    //\n    // when expression === string\n    //\n    //     gen = new require('math-codegen')\n    //     return gen.parse(expression).compile(Interval|BultInMath)\n    //\n    //     which is an object with the form\n    //\n    //     {\n    //       eval: function (scope) {\n    //         // math-codegen magic\n    //       }\n    //     }\n    //\n    // when expression === function\n    //\n    //    {\n    //      eval: expression\n    //    }\n    //\n    // othewise throw an error\n    if (typeof expression === 'string') {\n      var compiled = samplers[samplerName](expression);\n\n      if (global.math && samplerName === 'builtIn') {\n        // if mathjs is included use its evaluate method instead\n        return {\n          eval: compiled.evaluate || compiled.eval\n        };\n      }\n\n      return compiled;\n    } else if (typeof expression === 'function') {\n      return {\n        eval: expression\n      };\n    } else {\n      throw Error('expression must be a string or a function');\n    }\n  }\n\n  function compileIfPossible(meta, property) {\n    // compile the function using interval arithmetic, cache the result\n    // so that multiple calls with the same argument don't trigger the\n    // kinda expensive compilation process\n    var expression = meta[property];\n    var hiddenProperty = samplerName + '_Expression_' + property;\n    var hiddenCompiled = samplerName + '_Compiled_' + property;\n\n    if (expression !== meta[hiddenProperty]) {\n      meta[hiddenProperty] = expression;\n      meta[hiddenCompiled] = doCompile(expression);\n    }\n  }\n\n  function getCompiledExpression(meta, property) {\n    return meta[samplerName + '_Compiled_' + property];\n  }\n  /**\n   * Evaluates meta[property] with `variables`\n   *\n   * - Compiles meta[property] if it wasn't compiled already (also with cache\n   *   check)\n   * - Evaluates the resulting function with the merge of meta.scope and\n   *   `variables`\n   *\n   * @param {Object} meta\n   * @param {String} property\n   * @param {Object} variables\n   * @returns {Number|Array} The builtIn evaluator returns a number, the\n   * interval evaluator an array\n   */\n\n\n  function evaluate(meta, property, variables) {\n    // e.g.\n    //\n    //  meta: {\n    //    fn: 'x + 3',\n    //    scope: { y: 3 }\n    //  }\n    //  property: 'fn'\n    //  variables:  { x: 3 }\n    //\n    compileIfPossible(meta, property);\n    return getCompiledExpression(meta, property).eval(Object.assign({}, meta.scope || {}, variables));\n  }\n\n  return evaluate;\n}\n\nvar builtIn = generateEvaluator('builtIn');\nexports.builtIn = builtIn;\nvar interval = generateEvaluator('interval');\nexports.interval = interval;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AAEA,IAAMA,QAAQ,GAAG;AACfC,UAAQ,EAAEC,kCADK;AAEfC,SAAO,EAAEC;AAFM,CAAjB;;AAKA,IAAKC,MAAc,CAACC,IAApB,EAA0B;AACxBN,UAAQ,CAACG,OAAT,GAAoBE,MAAc,CAACC,IAAf,CAAoBC,OAAxC;AACD;;AAED,SAASC,iBAAT,CAA4BC,WAA5B,EAA+D;AAC7D,WAASC,SAAT,CAAoBC,UAApB,EAAsE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAClC,UAAMC,QAAQ,GAAGZ,QAAQ,CAACS,WAAD,CAAR,CAAsBE,UAAtB,CAAjB;;AACA,UAAKN,MAAc,CAACC,IAAf,IAAuBG,WAAW,KAAK,SAA5C,EAAuD;AACrD;AACA,eAAO;AAAEI,cAAI,EAAED,QAAQ,CAACE,QAAT,IAAqBF,QAAQ,CAACC;AAAtC,SAAP;AACD;;AACD,aAAOD,QAAP;AACD,KAPD,MAOO,IAAI,OAAOD,UAAP,KAAsB,UAA1B,EAAsC;AAC3C,aAAO;AAAEE,YAAI,EAAEF;AAAR,OAAP;AACD,KAFM,MAEA;AACL,YAAMI,KAAK,CAAC,2CAAD,CAAX;AACD;AACF;;AAED,WAASC,iBAAT,CAA4BC,IAA5B,EAAuCC,QAAvC,EAAuD;AACrD;AACA;AACA;AACA,QAAMP,UAAU,GAAGM,IAAI,CAACC,QAAD,CAAvB;AACA,QAAMC,cAAc,GAAGV,WAAW,GAAG,cAAd,GAA+BS,QAAtD;AACA,QAAME,cAAc,GAAGX,WAAW,GAAG,YAAd,GAA6BS,QAApD;;AACA,QAAIP,UAAU,KAAKM,IAAI,CAACE,cAAD,CAAvB,EAAyC;AACvCF,UAAI,CAACE,cAAD,CAAJ,GAAuBR,UAAvB;AACAM,UAAI,CAACG,cAAD,CAAJ,GAAuBV,SAAS,CAACC,UAAD,CAAhC;AACD;AACF;;AAED,WAASU,qBAAT,CAAgCJ,IAAhC,EAA2CC,QAA3C,EAA2D;AACzD,WAAOD,IAAI,CAACR,WAAW,GAAG,YAAd,GAA6BS,QAA9B,CAAX;AACD;AAED;;;;;;;;;;;;;;;;AAcA,WAASJ,QAAT,CAAmBG,IAAnB,EAA8BC,QAA9B,EAAgDI,SAAhD,EAA8D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,qBAAiB,CAACC,IAAD,EAAOC,QAAP,CAAjB;AAEA,WAAOG,qBAAqB,CAACJ,IAAD,EAAOC,QAAP,CAArB,CAAsCL,IAAtC,CACLU,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBP,IAAI,CAACQ,KAAL,IAAc,EAAhC,EAAoCH,SAApC,CADK,CAAP;AAGD;;AAED,SAAOR,QAAP;AACD;;AAED,IAAMX,OAAO,GAAGK,iBAAiB,CAAC,SAAD,CAAjC;AAGSkB;AAFT,IAAMzB,QAAQ,GAAGO,iBAAiB,CAAC,UAAD,CAAlC;AAEkBkB","names":["samplers","interval","interval_arithmetic_eval_1","builtIn","built_in_math_eval_1","global","math","compile","generateEvaluator","samplerName","doCompile","expression","compiled","eval","evaluate","Error","compileIfPossible","meta","property","hiddenProperty","hiddenCompiled","getCompiledExpression","variables","Object","assign","scope","exports"],"sourceRoot":"","sources":["../../src/helpers/eval.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}