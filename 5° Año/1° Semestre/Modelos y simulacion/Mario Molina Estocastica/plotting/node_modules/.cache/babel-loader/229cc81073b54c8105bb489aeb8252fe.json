{"ast":null,"code":"'use strict';\n\nvar extend = require('extend');\n\nvar types = {\n  ArrayNode: require('./node/ArrayNode'),\n  AssignmentNode: require('./node/AssignmentNode'),\n  ConditionalNode: require('./node/ConditionalNode'),\n  ConstantNode: require('./node/ConstantNode'),\n  FunctionNode: require('./node/FunctionNode'),\n  OperatorNode: require('./node/OperatorNode'),\n  SymbolNode: require('./node/SymbolNode'),\n  UnaryNode: require('./node/UnaryNode')\n};\n\nvar Interpreter = function Interpreter(owner, options) {\n  this.owner = owner;\n  this.options = extend({\n    factory: 'ns.factory',\n    raw: false,\n    rawArrayExpressionElements: true,\n    rawCallExpressionElements: false\n  }, options);\n};\n\nextend(Interpreter.prototype, types); // main method which decides which expression to call\n\nInterpreter.prototype.next = function (node) {\n  if (!(node.type in this)) {\n    throw new TypeError('the node type ' + node.type + ' is not implemented');\n  }\n\n  return this[node.type](node);\n};\n\nInterpreter.prototype.rawify = function (test, fn) {\n  var oldRaw = this.options.raw;\n\n  if (test) {\n    this.options.raw = true;\n  }\n\n  fn();\n\n  if (test) {\n    this.options.raw = oldRaw;\n  }\n};\n\nmodule.exports = Interpreter;","map":{"version":3,"sources":["/mnt/sda3/Lucas/Documents/facultad/5° Año/1° Semestre/Modelos y simulaciones/Mario Molina Estocastica/plotting/node_modules/math-codegen/lib/Interpreter.js"],"names":["extend","require","types","ArrayNode","AssignmentNode","ConditionalNode","ConstantNode","FunctionNode","OperatorNode","SymbolNode","UnaryNode","Interpreter","owner","options","factory","raw","rawArrayExpressionElements","rawCallExpressionElements","prototype","next","node","type","TypeError","rawify","test","fn","oldRaw","module","exports"],"mappings":"AAAA;;AACA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIC,KAAK,GAAG;AACVC,EAAAA,SAAS,EAAEF,OAAO,CAAC,kBAAD,CADR;AAEVG,EAAAA,cAAc,EAAEH,OAAO,CAAC,uBAAD,CAFb;AAGVI,EAAAA,eAAe,EAAEJ,OAAO,CAAC,wBAAD,CAHd;AAIVK,EAAAA,YAAY,EAAEL,OAAO,CAAC,qBAAD,CAJX;AAKVM,EAAAA,YAAY,EAAEN,OAAO,CAAC,qBAAD,CALX;AAMVO,EAAAA,YAAY,EAAEP,OAAO,CAAC,qBAAD,CANX;AAOVQ,EAAAA,UAAU,EAAER,OAAO,CAAC,mBAAD,CAPT;AAQVS,EAAAA,SAAS,EAAET,OAAO,CAAC,kBAAD;AARR,CAAZ;;AAWA,IAAIU,WAAW,GAAG,SAAdA,WAAc,CAAUC,KAAV,EAAiBC,OAAjB,EAA0B;AAC1C,OAAKD,KAAL,GAAaA,KAAb;AACA,OAAKC,OAAL,GAAeb,MAAM,CAAC;AACpBc,IAAAA,OAAO,EAAE,YADW;AAEpBC,IAAAA,GAAG,EAAE,KAFe;AAGpBC,IAAAA,0BAA0B,EAAE,IAHR;AAIpBC,IAAAA,yBAAyB,EAAE;AAJP,GAAD,EAKlBJ,OALkB,CAArB;AAMD,CARD;;AAUAb,MAAM,CAACW,WAAW,CAACO,SAAb,EAAwBhB,KAAxB,CAAN,C,CAEA;;AACAS,WAAW,CAACO,SAAZ,CAAsBC,IAAtB,GAA6B,UAAUC,IAAV,EAAgB;AAC3C,MAAI,EAAEA,IAAI,CAACC,IAAL,IAAa,IAAf,CAAJ,EAA0B;AACxB,UAAM,IAAIC,SAAJ,CAAc,mBAAmBF,IAAI,CAACC,IAAxB,GAA+B,qBAA7C,CAAN;AACD;;AACD,SAAO,KAAKD,IAAI,CAACC,IAAV,EAAgBD,IAAhB,CAAP;AACD,CALD;;AAOAT,WAAW,CAACO,SAAZ,CAAsBK,MAAtB,GAA+B,UAAUC,IAAV,EAAgBC,EAAhB,EAAoB;AACjD,MAAIC,MAAM,GAAG,KAAKb,OAAL,CAAaE,GAA1B;;AACA,MAAIS,IAAJ,EAAU;AACR,SAAKX,OAAL,CAAaE,GAAb,GAAmB,IAAnB;AACD;;AACDU,EAAAA,EAAE;;AACF,MAAID,IAAJ,EAAU;AACR,SAAKX,OAAL,CAAaE,GAAb,GAAmBW,MAAnB;AACD;AACF,CATD;;AAWAC,MAAM,CAACC,OAAP,GAAiBjB,WAAjB","sourcesContent":["'use strict'\nvar extend = require('extend')\n\nvar types = {\n  ArrayNode: require('./node/ArrayNode'),\n  AssignmentNode: require('./node/AssignmentNode'),\n  ConditionalNode: require('./node/ConditionalNode'),\n  ConstantNode: require('./node/ConstantNode'),\n  FunctionNode: require('./node/FunctionNode'),\n  OperatorNode: require('./node/OperatorNode'),\n  SymbolNode: require('./node/SymbolNode'),\n  UnaryNode: require('./node/UnaryNode')\n}\n\nvar Interpreter = function (owner, options) {\n  this.owner = owner\n  this.options = extend({\n    factory: 'ns.factory',\n    raw: false,\n    rawArrayExpressionElements: true,\n    rawCallExpressionElements: false\n  }, options)\n}\n\nextend(Interpreter.prototype, types)\n\n// main method which decides which expression to call\nInterpreter.prototype.next = function (node) {\n  if (!(node.type in this)) {\n    throw new TypeError('the node type ' + node.type + ' is not implemented')\n  }\n  return this[node.type](node)\n}\n\nInterpreter.prototype.rawify = function (test, fn) {\n  var oldRaw = this.options.raw\n  if (test) {\n    this.options.raw = true\n  }\n  fn()\n  if (test) {\n    this.options.raw = oldRaw\n  }\n}\n\nmodule.exports = Interpreter\n"]},"metadata":{},"sourceType":"script"}